#!/usr/bin/env python3
# -*- python -*-

# Copyright 2015 The Go Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import sys
import os
import argparse

import numpy as np
import matplotlib as mpl
mpl.use('GTK3Cairo')
mpl.rc('figure', facecolor='1')
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import seaborn as sns

import gctrace

def main():
    argp = argparse.ArgumentParser(
        description='''Plot CPU utilization versus wall-clock time from
        the output of GODEBUG=gctrace=1.''')
    argp.add_argument('--GOGC', metavar='PCT', type=float, default=100,
                      help='GOGC setting for this trace (default %(default)s)')
    argp.add_argument('trace', nargs='*', type=argparse.FileType(),
                      default=[sys.stdin],
                      help='gctrace file to read')
    args = argp.parse_args()

    for trace in args.trace:
        plotTrace(trace, args)
    plt.show()

def plotTrace(trace, args):
    # XXX Use a DataFrame?
    ts, util = [], []
    H_a_ts, H_a = [], []
    H_level_ts, H_T, H_g = [], [], []
    last_end = 0
    for rec in gctrace.parse(trace, GOGC=args.GOGC, omit_forced=False):
        # Always record heap actual
        H_a_ts.extend([rec.start, rec.end, rec.end])
        H_a.extend([rec.H_T, rec.H_a, rec.H_m])

        if rec.forced:
            last_end = rec.end
            continue

        now = rec.start
        ts.append(now)
        util.append(0)
        for i, (clock, cpu) in enumerate(zip(rec.clocks, rec.cpus)):
            ts.append(now)
            if i % 2 == 0:
                # Avoid issues from milliseconds rounding in trace
                util.append(1)
            elif clock > 0:
                util.append(cpu / clock / rec.gomaxprocs)
            else:
                util.append(0)
            now += clock
            ts.append(now)
            util.append(util[-1])
        ts.append(now)
        util.append(0)

        H_level_ts.extend([np.nan, last_end, rec.end])
        H_T.extend([np.nan, rec.H_T, rec.H_T])
        H_g.extend([np.nan, rec.H_g, rec.H_g])
        last_end = rec.end

    fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)

    if trace != sys.stdin:
        ax1.set_title(os.path.basename(trace.name))

    ax1.xaxis.set_major_formatter(tickerSec)
    ax1.set_ylabel('GC CPU utilization')
    ax1.fill_between(ts, util, alpha=0.5)
    ax1.fill_between(ts, util, where=[u>=1 for u in util])
    ax1.plot(ts, util)

    ax2.yaxis.set_major_formatter(tickerBytes)
    ax2.set_ylabel('Live heap size')
    ax2.plot(H_a_ts, H_a)
    H_T_line, = ax2.plot(H_level_ts, H_T)
    H_g_line, = ax2.plot(H_level_ts, H_g)
    ax2.legend([H_g_line, H_T_line], ['Goal', 'Trigger'], loc='best')

#    sns.despine()
    for axis in (ax1.yaxis, ax2.yaxis):
        axis.zoom(-0.5)
        axis.set_label_coords(-0.1, 0.5)
    fig.tight_layout()

def prettySec(x):
    if x == 0:
        return '0s'
    neg = ''
    if x < 0:
        neg = '-'
        x = -x
    units = (('ns', 1e-9), ('\u00B5s', 1e-6), ('ms', 1e-3), ('s', 1))
    unit = units[0]
    for u in units:
        if u[1] > x:
            break
        unit = u
    s = ('%.3f' % (x / unit[1])).rstrip('0').rstrip('.')
    return neg + s + unit[0]
tickerSec = ticker.FuncFormatter(lambda x, pos: prettySec(x))

def prettyBytes(x):
    if x == 0:
        return '0B'
    neg = ''
    if x < 0:
        neg = '-'
        x = -x
    units = ('B', 'KB', 'MB', 'GB', 'TB', 'PB')
    scale = 0
    while x >= 1000 and scale < len(units):
        x /= 1000
        scale += 1
    s = ('%.3f' % x).rstrip('0').rstrip('.')
    return neg + s + units[scale]
tickerBytes = ticker.FuncFormatter(lambda x, pos: prettyBytes(x))

if __name__ == '__main__':
    main()
